"""Patcher Agent for Agentic Researcher

This agent is responsible for fixing bugs in code generated by the coder agent.
It analyzes error outputs, identifies issues, and provides patched code solutions.
"""

import json
import sys
import os

# Add project root to the Python path to enable imports
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
if project_root not in sys.path:
    sys.path.append(project_root)
import re
from typing import Dict, List, Any, Optional, Tuple, Union

from src.db.sqlite_manager import SQLiteManager
from src.utils.openai_client import AzureOpenAIClient

class PatcherAgent:
    """
    Patcher Agent that fixes bugs in code
    
    This agent analyzes error outputs from the runner agent,
    identifies coding issues, and proposes fixed solutions.
    """
    
    def __init__(self):
        """Initialize the PatcherAgent"""
        self.name = "patcher"
        
        # Initialize database connections
        self.sqlite_manager = SQLiteManager()
        
        # Initialize Azure OpenAI client
        self.openai_client = AzureOpenAIClient()
    
    def analyze_error(self, error_message: str, code_content: str, 
                    execution_result: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Analyze an error message and identify the bug in the code
        
        Args:
            error_message: Error message text
            code_content: Original code content
            execution_result: Optional full execution result from runner agent
            
        Returns:
            Dict: Error analysis with bug location and description
        """
        # Build prompt for error analysis
        # Build the execution result part separately to avoid f-string issues with backslashes
        execution_result_part = ""
        if execution_result:
            execution_result_part = "EXECUTION RESULT:\n" + json.dumps(execution_result, indent=2)
        
        prompt = f"""You are an expert Python debugger. Analyze the following error message and code to identify the bug.

ERROR MESSAGE:
{error_message}

CODE:
```python
{code_content}
```

{execution_result_part}

Identify the bug in this code and provide a detailed analysis. Focus on:
1. What caused the error
2. The line number(s) where the bug appears
3. A clear explanation of the issue
4. Potential ways to fix the bug

Format your response as a JSON object with the following structure:
{{
    "error_type": "Type of error (e.g., SyntaxError, NameError, etc.)",
    "bug_lines": [line_numbers_with_bugs],
    "explanation": "Detailed explanation of the bug",
    "fix_suggestions": [
        "Suggestion 1",
        "Suggestion 2",
        ...
    ]
}}
"""

        # Call Azure OpenAI API
        response = self.openai_client.generate_completion(
            messages=[
                {"role": "system", "content": "You are an expert Python debugger."},
                {"role": "user", "content": prompt}
            ]
        )
        
        # Parse and return the response
        try:
            analysis = json.loads(response)
        except json.JSONDecodeError:
            # If parsing fails, try to extract JSON from the response
            import re
            json_match = re.search(r'```json\s*([\s\S]+?)\s*```', response)
            if json_match:
                try:
                    analysis = json.loads(json_match.group(1))
                except:
                    analysis = self._create_fallback_analysis(error_message, response)
            else:
                analysis = self._create_fallback_analysis(error_message, response)
        
        return analysis
    
    def patch_code(self, code_files: List[Dict[str, str]], error_analysis: Dict[str, Any],
                  project_id: int, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Patch code based on error analysis
        
        Args:
            code_files: List of code files (with file_name and content)
            error_analysis: Error analysis from analyze_error method
            project_id: Project ID
            context: Additional context information
            
        Returns:
            Dict: Patched code files and explanation
        """
        # Log the start of patching
        self.sqlite_manager.save_agent_state(
            project_id=project_id,
            agent_type="patcher",
            state_data={
                "status": "patching",
                "error_type": error_analysis.get("error_type", "Unknown error")
            }
        )
        
        try:
            # Determine which file needs patching
            # If multiple files, we need to identify the one with the error
            file_to_patch = None
            for file_info in code_files:
                file_name = file_info.get("file_name", "")
                # Skip non-Python files for now (could expand later)
                if not file_name.endswith(".py"):
                    continue
                    
                # If this is the only Python file, or if we find error lines in it, use this file
                if len([f for f in code_files if f.get("file_name", "").endswith(".py")]) == 1 or \
                   self._code_contains_error_lines(file_info.get("content", ""), error_analysis.get("bug_lines", [])):
                    file_to_patch = file_info
                    break
            
            if not file_to_patch:
                # If we can't identify the file, use the first Python file
                python_files = [f for f in code_files if f.get("file_name", "").endswith(".py")]
                if python_files:
                    file_to_patch = python_files[0]
                else:
                    raise Exception("No Python files found to patch")
            
            # Build patching prompt
            file_name = file_to_patch.get("file_name", "unknown.py")
            code_content = file_to_patch.get("content", "")
            
            error_type = error_analysis.get("error_type", "Unknown error")
            bug_lines = error_analysis.get("bug_lines", [])
            explanation = error_analysis.get("explanation", "Unspecified bug")
            fix_suggestions = error_analysis.get("fix_suggestions", ["No specific suggestions provided"])
            
            # Format the bug lines for prompt
            bug_lines_str = ", ".join(map(str, bug_lines)) if bug_lines else "Unknown"
            fix_suggestions_str = "\n".join([f"- {suggestion}" for suggestion in fix_suggestions])
            
            prompt = f"""You are an expert Python fixer. Fix the bugs in this code based on the error analysis.

FILE: {file_name}

ORIGINAL CODE:
```python
{code_content}
```

ERROR ANALYSIS:
- Error type: {error_type}
- Bug lines: {bug_lines_str}
- Explanation: {explanation}
- Fix suggestions:
{fix_suggestions_str}

Provide the fixed version of the code. Make sure to address all identified issues while maintaining the original functionality. Include clear explanations as comments next to your changes.

Format your response as a JSON object with the following structure:
{{
    "file_name": "{file_name}",
    "patched_code": "Full fixed code with all necessary changes",
    "changes_made": [
        "Description of change 1",
        "Description of change 2",
        ...
    ],
    "explanation": "Overall explanation of the fixes"
}}
"""

            # Call Azure OpenAI API
            response = self.openai_client.generate_completion(
                messages=[
                    {"role": "system", "content": "You are an expert Python fixer."},
                    {"role": "user", "content": prompt}
                ]
            )
            
            # Parse response
            try:
                patch_result = json.loads(response)
            except json.JSONDecodeError:
                # If parsing fails, try to extract JSON from the response
                import re
                json_match = re.search(r'```json\s*([\s\S]+?)\s*```', response)
                if json_match:
                    try:
                        patch_result = json.loads(json_match.group(1))
                    except:
                        # Extract code manually as fallback
                        patch_result = self._extract_patched_code(response, file_name)
                else:
                    # Extract code manually as fallback
                    patch_result = self._extract_patched_code(response, file_name)
            
            # Create result with patched files
            patched_files = []
            for file_info in code_files:
                if file_info.get("file_name") == file_name:
                    # Replace with patched version
                    patched_files.append({
                        "file_name": file_name,
                        "content": patch_result.get("patched_code", file_info.get("content"))
                    })
                else:
                    # Keep original file
                    patched_files.append(file_info)
            
            result = {
                "patched_files": patched_files,
                "changes_made": patch_result.get("changes_made", []),
                "explanation": patch_result.get("explanation", "Patched the code to fix identified issues"),
                "original_error": error_analysis,
                "patched_file": file_name
            }
            
            # Log completion of patching
            self.sqlite_manager.save_agent_state(
                project_id=project_id,
                agent_type="patcher",
                state_data={
                    "status": "completed",
                    "patched_file": file_name,
                    "changes_count": len(result["changes_made"])
                }
            )
            
            return result
            
        except Exception as e:
            # Log error
            self.sqlite_manager.save_agent_state(
                project_id=project_id,
                agent_type="patcher",
                state_data={
                    "status": "error",
                    "error": str(e)
                }
            )
            
            return {
                "status": "error",
                "error": str(e),
                "original_error": error_analysis
            }
    
    def _create_fallback_analysis(self, error_message: str, response: str) -> Dict[str, Any]:
        """Create a fallback error analysis when JSON parsing fails"""
        # Extract error type if possible
        error_type_match = re.search(r'([A-Za-z]+Error|Exception):', error_message)
        error_type = error_type_match.group(1) if error_type_match else "UnknownError"
        
        # Try to extract line numbers from error message
        line_num_match = re.search(r'line (\d+)', error_message)
        bug_lines = [int(line_num_match.group(1))] if line_num_match else []
        
        return {
            "error_type": error_type,
            "bug_lines": bug_lines,
            "explanation": "Failed to parse full analysis. Original error: " + error_message,
            "fix_suggestions": ["Check the error message and fix the issue manually"],
            "raw_response": response
        }
    
    def _code_contains_error_lines(self, code_content: str, bug_lines: List[int]) -> bool:
        """Check if code contains the reported error lines"""
        if not bug_lines:
            return False
            
        code_lines = code_content.split('\n')
        max_line = len(code_lines)
        
        for line_num in bug_lines:
            if 1 <= line_num <= max_line:  # Line numbers start at 1
                return True
                
        return False
    
    def _extract_patched_code(self, response: str, file_name: str) -> Dict[str, Any]:
        """Extract patched code from non-JSON response"""
        # Try to extract code blocks
        code_blocks = re.findall(r'```(?:python)?\n([\s\S]+?)\n```', response)
        
        patched_code = ""
        if code_blocks:
            # Use the largest code block as the patched code
            patched_code = max(code_blocks, key=len)
        else:
            # If no code blocks, try to extract based on indentation patterns
            lines = response.split('\n')
            code_lines = []
            in_code_section = False
            
            for line in lines:
                if line.strip().startswith('def ') or line.strip().startswith('class '):
                    in_code_section = True
                    code_lines.append(line)
                elif in_code_section and (line.startswith('    ') or not line.strip()):
                    code_lines.append(line)
                elif in_code_section and line.strip() and not line.startswith('    '):
                    in_code_section = False
            
            if code_lines:
                patched_code = '\n'.join(code_lines)
        
        # Extract explanations
        changes = []
        explanation_section = re.search(r'(?:changes|fixes)\s*(?:made)?:\s*([\s\S]+?)(?:\n\n|\Z)', response, re.IGNORECASE)
        if explanation_section:
            explanation_text = explanation_section.group(1)
            # Split by bullet points or numbered items
            changes = re.findall(r'(?:^|\n)\s*(?:\*|-|\d+\.)\s*(.+?)(?=\s*(?:\*|-|\d+\.|$))', explanation_text)
            changes = [change.strip() for change in changes if change.strip()]
        
        # Extract overall explanation
        explanation = ""
        expl_section = re.search(r'(?:explanation|summary):\s*([\s\S]+?)(?:\n\n|\Z)', response, re.IGNORECASE)
        if expl_section:
            explanation = expl_section.group(1).strip()
        else:
            # Use first paragraph as explanation
            paragraphs = [p.strip() for p in response.split('\n\n') if p.strip()]
            if paragraphs:
                explanation = paragraphs[0]
        
        return {
            "file_name": file_name,
            "patched_code": patched_code,
            "changes_made": changes if changes else ["Patched code to fix identified issues"],
            "explanation": explanation if explanation else "Fixed code issues based on error analysis"
        }


# Example usage
if __name__ == "__main__":
    patcher_agent = PatcherAgent()
    
    # Example error and code
    sample_error = "NameError: name 'np' is not defined"
    sample_code = """
# VIX Calculator
def calculate_historical_volatility(prices, window=30):
    # Calculate log returns
    log_returns = np.log(prices[1:] / prices[:-1])
    
    # Calculate rolling standard deviation
    volatility = np.std(log_returns[-window:]) * np.sqrt(252)  # Annualized
    
    return volatility

# Test the function
prices = [100, 102, 98, 101, 103, 99, 98, 102, 105, 106]
print(calculate_historical_volatility(prices))
"""
    
    # Analyze error
    analysis = patcher_agent.analyze_error(sample_error, sample_code)
    
    print("Error Analysis:")
    print(json.dumps(analysis, indent=2))
    
    # Patch the code
    result = patcher_agent.patch_code(
        code_files=[{"file_name": "vix_calculator.py", "content": sample_code}],
        error_analysis=analysis,
        project_id=1
    )
    
    print("\nPatched Code:")
    for file in result["patched_files"]:
        print(f"\nFile: {file['file_name']}")
        print(file['content'])
